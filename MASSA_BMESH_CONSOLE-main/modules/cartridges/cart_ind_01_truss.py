import bpy
import bmesh
import math
from mathutils import Vector, Matrix
from bpy.props import FloatProperty, EnumProperty, BoolProperty, IntProperty
from ...operators.massa_base import Massa_OT_Base

CARTRIDGE_META = {
    "name": "IND_01: Space Frame",
    "id": "ind_01_truss",
    "icon": "MOD_WIREFRAME",
    "scale_class": "STANDARD",
    "flags": {
        "ALLOW_SOLIDIFY": False,
        "USE_WELD": True,
        "ALLOW_CHAMFER": False, # Wireframe usually doesn't bevel well
        "LOCK_PIVOT": True,
    },
}

class MASSA_OT_IndTruss(Massa_OT_Base):
    bl_idname = "massa.gen_ind_01_truss"
    bl_label = "IND Truss"
    bl_options = {"REGISTER", "UNDO", "PRESET"}

    # Dimensions
    length: FloatProperty(name="Length", default=4.0, min=0.1)
    width: FloatProperty(name="Width", default=0.5, min=0.1)
    height: FloatProperty(name="Height", default=0.5, min=0.1)

    # Grid
    segs_x: IntProperty(name="Segments X", default=4, min=1)

    # Struts
    strut_thick: FloatProperty(name="Strut Thickness", default=0.05, min=0.001)
    cross_bracing: BoolProperty(name="Cross Bracing", default=True)

    def get_slot_meta(self):
        return {
            0: {"name": "Metal", "uv": "BOX", "phys": "METAL_STEEL"},
            9: {"name": "Socket Anchor", "sock": True}
        }

    def build_shape(self, bm):
        # 1. Initialize Layers
        uv_layer = bm.loops.layers.uv.verify()
        edge_slots = bm.edges.layers.int.get("MASSA_EDGE_SLOTS")
        if not edge_slots:
            edge_slots = bm.edges.layers.int.new("MASSA_EDGE_SLOTS")

        # 2. Create Base Mesh (Quads)
        l, w, h = self.length, self.width, self.height
        sx = self.segs_x
        dx = l / sx

        rails = [[], [], [], []]

        # Create vertices along length
        for i in range(sx + 1):
            x = -l/2 + i*dx
            v1 = bm.verts.new(Vector((x, -w/2, -h/2)))
            v2 = bm.verts.new(Vector((x, w/2, -h/2)))
            v3 = bm.verts.new(Vector((x, w/2, h/2)))
            v4 = bm.verts.new(Vector((x, -w/2, h/2)))

            rails[0].append(v1)
            rails[1].append(v2)
            rails[2].append(v3)
            rails[3].append(v4)

        bm.verts.ensure_lookup_table()

        # Create Faces (Tube Structure)
        faces = []
        for i in range(sx):
            # Bottom (0-1)
            f1 = bm.faces.new((rails[0][i], rails[1][i], rails[1][i+1], rails[0][i+1]))
            # Right (1-2)
            f2 = bm.faces.new((rails[1][i], rails[2][i], rails[2][i+1], rails[1][i+1]))
            # Top (2-3)
            f3 = bm.faces.new((rails[2][i], rails[3][i], rails[3][i+1], rails[2][i+1]))
            # Left (3-0)
            f4 = bm.faces.new((rails[3][i], rails[0][i], rails[0][i+1], rails[3][i+1]))

            faces.extend([f1, f2, f3, f4])

        bm.faces.ensure_lookup_table()

        # Cross Bracing (Poke faces to create X pattern)
        if self.cross_bracing:
            structural_faces = faces
            # Note: We poke the faces which splits them into 4 tris
            res = bmesh.ops.poke(bm, faces=structural_faces)
            # Update faces list if needed, but wireframe operates on all faces by default if none passed
            # Or we can just let it run on everything since we only have these faces.

        # 3. Solidify (Wireframe to Mesh)
        # Use bmesh.ops.wireframe to turn faces into struts
        # Note: 'edges' argument removed as it is invalid. 'faces' arg is inferred or explicit.
        bmesh.ops.wireframe(bm, faces=bm.faces, thickness=self.strut_thick, use_replace=True, use_boundary=True, use_even_offset=True)

        # 4. Cleanup & Roles
        # Mark all new edges as Perimeter
        for e in bm.edges:
            e[edge_slots] = 1 # Perimeter (Hard Edge)

        # 5. Sockets
        # Add sockets at ends (Faces at min X and max X)
        # Identify faces whose normal is (-1,0,0) or (1,0,0)
        # With wireframe, we check faces on the ends generated by wireframe boundary
        bm.faces.ensure_lookup_table()
        for f in bm.faces:
            n = f.normal
            c = f.calc_center_median()
            if abs(c.x + l/2) < 0.01 and n.x < -0.9: # Left End
                f.material_index = 9 # Socket Anchor
            elif abs(c.x - l/2) < 0.01 and n.x > 0.9: # Right End
                f.material_index = 9

        # 6. Manual UVs
        # Box Mapping for everything (struts are square)
        scale = getattr(self, "uv_scale_0", 1.0) # Check if property exists? Or just fallback 1.0
        # If property not defined in class, use 1.0
        
        for f in bm.faces:
            if f.material_index == 9: continue

            n = f.normal
            for l in f.loops:
                if abs(n.x) > 0.5:
                    l[uv_layer].uv = (l.vert.co.y * scale, l.vert.co.z * scale)
                elif abs(n.y) > 0.5:
                    l[uv_layer].uv = (l.vert.co.x * scale, l.vert.co.z * scale)
                else:
                    l[uv_layer].uv = (l.vert.co.x * scale, l.vert.co.y * scale)

    def draw_shape_ui(self, layout):
        col = layout.column(align=True)
        col.prop(self, "length")
        col.prop(self, "width")
        col.prop(self, "height")
        layout.separator()
        col.prop(self, "segs_x")
        col.prop(self, "strut_thick")
        col.prop(self, "cross_bracing")
